Goal: Update the database and API to allow couples to create custom ceremony budget categories that are strictly associated with a specific wedding, a ceremony type, and a system budget bucket.Step 1: Database Schema UpdateUpdate shared/schema.ts to implement the following changes to the ceremony_template_items table (rename it to ceremony_budget_categories as part of this process if not already done):Rename Table: ceremony_template_items $\rightarrow$ ceremony_budget_categories.Add Column: weddingId (varchar) referencing weddings.id. This should be nullable (NULL means a system-defined global template, a value means it is a custom item for that specific couple).Ensure Foreign Keys:ceremonyTypeId (already exists as templateId) must reference ceremony_types.id (formerly ceremony_templates).budgetBucketCategoryId (formerly budgetBucket) must be .notNull() and reference the budget_categories.id table.Step 2: Backend Logic & APIUpdate API: Modify the POST /api/ceremony-budget-categories endpoint in server/routes/ceremony-templates.ts.Validation: Use Zod to ensure that when a couple creates an item, the weddingId, ceremonyTypeId, and budgetBucketCategoryId are all provided.Fetch Logic: Update the retrieval query so that when fetching items for a ceremony, it returns:WHERE ceremony_type_id = :id AND (wedding_id IS NULL OR wedding_id = :currentWeddingId).Step 3: Frontend EnforcementForm Update: In the "Add Custom Item" UI component, add a required dropdown for "Budget Category/Bucket."Data Source: This dropdown must be populated from the system's budget_bucket_categories (currently budgetCategories in the schema).Mapping: Ensure that any custom item created by a couple is automatically included in the "Single Ledger" math for its associated bucket to prevent "orphan" expenses.Why this prompt works for your refactor:Renaming & Normalization: It follows your requirement to rename tables like ceremony_template_items while cleaning up the legacy string-based budgetBucket field.Multi-Tenancy: By adding the nullable weddingId, you allow your system to store both global standards and user-defined customs in one clean table.Relational Integrity: By making the budgetBucketCategoryId .notNull(), you "force" the couple to associate their custom item with a high-level bucket, which is the only way to keep your "Single Ledger" analytics accurate.