import { Router, Request, Response } from "express";
import { IStorage } from "../storage";
import { requireAuth, AuthRequest } from "../auth-middleware";
import { insertCeremonyExplainerSchema } from "@shared/schema";
import { generateCeremonyExplainer } from "../ai/gemini";

export async function createCeremonyExplainersRouter(storage: IStorage): Promise<Router> {
  const router = Router();

  router.get("/wedding/:weddingId", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const weddingId = req.params.weddingId;

      const wedding = await storage.getWedding(weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      const explainers = await storage.getCeremonyExplainersByWedding(weddingId);
      res.json(explainers);
    } catch (error) {
      console.error("Error fetching ceremony explainers:", error);
      res.status(500).json({ error: "Failed to fetch ceremony explainers" });
    }
  });

  router.post("/generate", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { weddingId, eventId } = req.body;

      if (!weddingId || !eventId) {
        return res.status(400).json({ error: "Wedding ID and Event ID are required" });
      }

      const wedding = await storage.getWedding(weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      const event = await storage.getEvent(eventId);
      if (!event || event.weddingId !== weddingId) {
        return res.status(404).json({ error: "Event not found" });
      }

      const existingExplainer = await storage.getCeremonyExplainerByEvent(eventId);
      if (existingExplainer) {
        return res.status(400).json({ error: "An explainer already exists for this event", existingId: existingExplainer.id });
      }

      const isFusionWedding = wedding.tradition === 'mixed' || wedding.partnerNewToTraditions === true;
      const subTraditions = wedding.subTraditions || (wedding.subTradition ? [wedding.subTradition] : []);

      const generated = await generateCeremonyExplainer({
        ceremonyType: event.type,
        ceremonyName: event.name,
        tradition: wedding.tradition,
        subTraditions,
        isFusionWedding,
        eventDescription: event.description || undefined,
        dressCode: event.dressCode || undefined,
      });

      const explainer = await storage.createCeremonyExplainer({
        weddingId,
        eventId,
        ceremonyType: event.type,
        tradition: wedding.tradition,
        title: generated.title,
        shortExplainer: generated.shortExplainer,
        fullExplainer: generated.fullExplainer,
        keyMoments: generated.keyMoments,
        culturalSignificance: generated.culturalSignificance,
        guestTips: generated.guestTips,
        attireGuidance: generated.attireGuidance,
        targetAudience: isFusionWedding ? "new_to_tradition" : "all",
        isAutoGenerated: true,
        isPublished: false,
      });

      res.status(201).json(explainer);
    } catch (error) {
      console.error("Error generating ceremony explainer:", error);
      res.status(500).json({ error: "Failed to generate ceremony explainer" });
    }
  });

  router.post("/generate-all", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { weddingId } = req.body;

      if (!weddingId) {
        return res.status(400).json({ error: "Wedding ID is required" });
      }

      const wedding = await storage.getWedding(weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      const events = await storage.getEventsByWedding(weddingId);
      const existingExplainers = await storage.getCeremonyExplainersByWedding(weddingId);
      const existingEventIds = new Set(existingExplainers.map(e => e.eventId));

      const eventsToGenerate = events.filter(e => !existingEventIds.has(e.id));

      if (eventsToGenerate.length === 0) {
        return res.json({ message: "All events already have explainers", generated: 0, explainers: existingExplainers });
      }

      const isFusionWedding = wedding.tradition === 'mixed' || wedding.partnerNewToTraditions === true;
      const subTraditions = wedding.subTraditions || (wedding.subTradition ? [wedding.subTradition] : []);

      const newExplainers = [];
      for (const event of eventsToGenerate) {
        try {
          const generated = await generateCeremonyExplainer({
            ceremonyType: event.type,
            ceremonyName: event.name,
            tradition: wedding.tradition,
            subTraditions,
            isFusionWedding,
            eventDescription: event.description || undefined,
            dressCode: event.dressCode || undefined,
          });

          const explainer = await storage.createCeremonyExplainer({
            weddingId,
            eventId: event.id,
            ceremonyType: event.type,
            tradition: wedding.tradition,
            title: generated.title,
            shortExplainer: generated.shortExplainer,
            fullExplainer: generated.fullExplainer,
            keyMoments: generated.keyMoments,
            culturalSignificance: generated.culturalSignificance,
            guestTips: generated.guestTips,
            attireGuidance: generated.attireGuidance,
            targetAudience: isFusionWedding ? "new_to_tradition" : "all",
            isAutoGenerated: true,
            isPublished: false,
          });
          newExplainers.push(explainer);
        } catch (error) {
          console.error(`Failed to generate explainer for event ${event.id}:`, error);
        }
      }

      const allExplainers = await storage.getCeremonyExplainersByWedding(weddingId);
      res.json({ message: `Generated ${newExplainers.length} new explainers`, generated: newExplainers.length, explainers: allExplainers });
    } catch (error) {
      console.error("Error generating ceremony explainers:", error);
      res.status(500).json({ error: "Failed to generate ceremony explainers" });
    }
  });

  router.patch("/:id", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const explainerId = req.params.id;

      const existingExplainer = await storage.getCeremonyExplainer(explainerId);
      if (!existingExplainer) {
        return res.status(404).json({ error: "Explainer not found" });
      }

      const wedding = await storage.getWedding(existingExplainer.weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(existingExplainer.weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      const partialSchema = insertCeremonyExplainerSchema.partial();
      const validatedData = partialSchema.parse(req.body);

      const updated = await storage.updateCeremonyExplainer(explainerId, { 
        ...validatedData, 
        isAutoGenerated: false 
      });
      res.json(updated);
    } catch (error) {
      console.error("Error updating ceremony explainer:", error);
      res.status(500).json({ error: "Failed to update ceremony explainer" });
    }
  });

  router.post("/:id/publish", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const explainerId = req.params.id;

      const existingExplainer = await storage.getCeremonyExplainer(explainerId);
      if (!existingExplainer) {
        return res.status(404).json({ error: "Explainer not found" });
      }

      const wedding = await storage.getWedding(existingExplainer.weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(existingExplainer.weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      const published = await storage.publishCeremonyExplainer(explainerId);
      res.json(published);
    } catch (error) {
      console.error("Error publishing ceremony explainer:", error);
      res.status(500).json({ error: "Failed to publish explainer" });
    }
  });

  router.post("/:id/unpublish", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const explainerId = req.params.id;

      const existingExplainer = await storage.getCeremonyExplainer(explainerId);
      if (!existingExplainer) {
        return res.status(404).json({ error: "Explainer not found" });
      }

      const wedding = await storage.getWedding(existingExplainer.weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(existingExplainer.weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      const unpublished = await storage.unpublishCeremonyExplainer(explainerId);
      res.json(unpublished);
    } catch (error) {
      console.error("Error unpublishing ceremony explainer:", error);
      res.status(500).json({ error: "Failed to unpublish explainer" });
    }
  });

  router.delete("/:id", await requireAuth(storage, false), async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const explainerId = req.params.id;

      const existingExplainer = await storage.getCeremonyExplainer(explainerId);
      if (!existingExplainer) {
        return res.status(404).json({ error: "Explainer not found" });
      }

      const wedding = await storage.getWedding(existingExplainer.weddingId);
      if (!wedding) {
        return res.status(404).json({ error: "Wedding not found" });
      }

      const user = await storage.getUser(authReq.session.userId);
      const isOwner = wedding.userId === authReq.session.userId;
      const isCollaborator = user ? await storage.isWeddingCollaborator(existingExplainer.weddingId, user.email) : false;

      if (!isOwner && !isCollaborator) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.deleteCeremonyExplainer(explainerId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting ceremony explainer:", error);
      res.status(500).json({ error: "Failed to delete explainer" });
    }
  });

  return router;
}

export function createPublicCeremonyExplainersRouter(storage: IStorage): Router {
  const router = Router();

  router.get("/wedding/:slug", async (req: Request, res: Response) => {
    try {
      const slug = req.params.slug;

      const website = await storage.getWeddingWebsiteBySlug(slug);
      if (!website) {
        return res.status(404).json({ error: "Wedding website not found" });
      }

      const explainers = await storage.getPublishedCeremonyExplainersByWedding(website.weddingId);
      res.json(explainers);
    } catch (error) {
      console.error("Error fetching public ceremony explainers:", error);
      res.status(500).json({ error: "Failed to fetch ceremony explainers" });
    }
  });

  return router;
}
